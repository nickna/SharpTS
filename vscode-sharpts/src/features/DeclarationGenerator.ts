/**
 * Generates TypeScript declaration files for SharpTS annotations.
 * Creates sharpts.d.ts in each workspace folder root.
 */

import * as vscode from 'vscode';
import * as path from 'path';
import { BridgeClient } from '../bridge/BridgeClient';
import {
    AttributeInfo,
    ListAttributesResult,
    AttributeDetailResult
} from '../bridge/BridgeProtocol';

// Core SharpTS annotations (always available, even without bridge)
const BUILTIN_DECLARATIONS = `
// Built-in SharpTS annotations
declare function DotNetType(typeName: string): ClassDecorator;
declare function DotNetAttribute(attributeName: string, ...args: any[]): ClassDecorator & PropertyDecorator & MethodDecorator;
declare function DotNetMethod(methodName: string): MethodDecorator;
declare function DotNetProperty(propertyName: string): PropertyDecorator;
declare function DotNetField(fieldName: string): PropertyDecorator;
declare function DotNetEvent(eventName: string): PropertyDecorator;
`;

const BUILTIN_NAMES = new Set([
    'DotNetType',
    'DotNetAttribute',
    'DotNetMethod',
    'DotNetProperty',
    'DotNetField',
    'DotNetEvent'
]);

export class DeclarationGenerator {
    constructor(private bridge: BridgeClient) {}

    /**
     * Generate sharpts.d.ts for a workspace folder.
     */
    async generate(workspaceFolder: vscode.WorkspaceFolder): Promise<void> {
        // Place directly in workspace root so TypeScript finds it
        const filePath = path.join(workspaceFolder.uri.fsPath, 'sharpts.d.ts');

        // Generate content
        const content = await this.generateContent();

        // Write file
        const fileUri = vscode.Uri.file(filePath);
        await vscode.workspace.fs.writeFile(fileUri, Buffer.from(content, 'utf8'));
    }

    /**
     * Generate the full declaration file content.
     */
    private async generateContent(): Promise<string> {
        const lines: string[] = [
            '// Auto-generated by SharpTS extension',
            '// Do not edit manually - regenerated on extension activation',
            '',
            BUILTIN_DECLARATIONS.trim(),
            ''
        ];

        if (!this.bridge.ready) {
            lines.push('// Bridge not available - only built-in annotations declared');
            return lines.join('\n');
        }

        try {
            // Get all attributes from bridge
            const listResponse = await this.bridge.sendRequest<ListAttributesResult>(
                'list-attributes'
            );

            if (!listResponse.success || !listResponse.body?.attributes) {
                lines.push('// No attributes available from bridge');
                return lines.join('\n');
            }

            lines.push('// .NET Attributes from loaded assemblies');
            lines.push('');

            // Generate declarations for each attribute
            for (const attr of listResponse.body.attributes) {
                // Skip built-in annotations
                if (BUILTIN_NAMES.has(attr.name)) {
                    continue;
                }

                try {
                    const infoResponse = await this.bridge.sendRequest<AttributeDetailResult>(
                        'get-attribute-info',
                        { typeName: attr.fullName }
                    );

                    if (infoResponse.success && infoResponse.body) {
                        const decl = this.generateAttributeDeclaration(attr, infoResponse.body);
                        lines.push(decl);
                    }
                } catch {
                    // Skip attributes we can't get info for
                }
            }
        } catch {
            lines.push('// Failed to fetch attributes from bridge');
        }

        return lines.join('\n');
    }

    /**
     * Generate a declaration for a single attribute.
     */
    private generateAttributeDeclaration(
        attr: AttributeInfo,
        details: AttributeDetailResult
    ): string {
        const lines: string[] = [];

        // Add JSDoc comment with full name
        lines.push(`/** @see ${details.fullName} (${attr.assembly}) */`);

        // Generate function signature(s)
        if (details.constructors.length === 0) {
            // No-arg attribute
            lines.push(
                `declare function ${attr.name}(): ClassDecorator & PropertyDecorator & MethodDecorator;`
            );
        } else {
            // Generate overloads for each constructor
            for (const ctor of details.constructors) {
                const params = ctor.parameters
                    .map(p => {
                        const optional = p.isOptional ? '?' : '';
                        return `${p.name}${optional}: ${this.mapType(p.type)}`;
                    })
                    .join(', ');

                lines.push(
                    `declare function ${attr.name}(${params}): ClassDecorator & PropertyDecorator & MethodDecorator;`
                );
            }
        }

        lines.push('');
        return lines.join('\n');
    }

    /**
     * Map .NET types to TypeScript types.
     * The bridge already maps most types, but handle edge cases.
     */
    private mapType(dotNetType: string): string {
        const typeMap: Record<string, string> = {
            'string': 'string',
            'number': 'number',
            'boolean': 'boolean',
            'any': 'any',
            'Type': 'Function', // System.Type maps to Function in TS
            'object': 'any'
        };

        // Handle arrays
        if (dotNetType.endsWith('[]')) {
            const elementType = dotNetType.slice(0, -2);
            return `${this.mapType(elementType)}[]`;
        }

        return typeMap[dotNetType] || 'any';
    }
}
